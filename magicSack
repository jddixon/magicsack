#!/usr/bin/python3
#
# ~/dev/py/magicsack/magicSack

import binascii, getpass, json, os, shutil, sys
from pbkdf2         import PBKDF2       # note name of package is u/c
from Crypto.Cipher  import AES
from Crypto.Hash      import SHA        # presumably SHA1
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_PSS
from argparse       import ArgumentParser

from buildList      import BuildList
from nlhtree        import NLHTree
from rnglib         import SystemRNG
from xlattice.crypto import AES_BLOCK_SIZE, addPKCS7Padding, stripPKCS7Padding
from xlattice.lfs   import mkdir_p
from xlattice.ui    import confirmYorN, passwdStrength
from magicsack      import *


def verifyPassPhrase(globals, passPhrase):
    # DEBUG
    #print("entering verifyPassPhrase")
    #print("globals is a ", type(globals))
    # END
    ok = True
    magicDir    = globals.magicDir
    if not os.path.exists(magicDir):
        print("%s does not exist; cannot continue" % magicDir)
        sys.exit(1)
    configFile = os.path.join(magicDir, 'cfg.json')
    if not os.path.exists(configFile):
        print("%s does not exist; cannot continue" % configFile)
        sys.exit(1)
    try:
        with open(configFile, 'r') as f:
            data = f.read()
    except Exception as e:
        print("error reading configuration file: %s" % e)
        sys.exit(1)
    try:
        cfg = json.loads(data)
    except Exception as e:
        print("error parsing json configuration file: %s" % e)
        sys.exit(1)
    # DEBUG
    print("CONFIGURATION:")
    print(data)
    # END
    
    globals.hexSalt = cfg['salt']
    globals.salt    = binascii.a2b_hex(globals.hexSalt)
    # DEBUG
    #print("salt as seen by verify:\n    %s" % binascii.b2a_hex(globals.salt).decode('utf-8'))
    # END
    globals.uDir    = cfg['uDir']
  
    # Read the puzzle file, then check that the salt encrypted there
    # matches the salt in the configuration file.  If it doesn't, the
    # key and therefore the passphrase are wrong.

    pathToPuzzle = os.path.join(magicDir, 'puzzle')
    with open(pathToPuzzle, 'rb') as f:
        puzzle = f.read()
    # DEBUG
    #print("puzzle read from disk (%d bytes):" % len(puzzle))
    #print("%s" % binascii.b2a_hex(puzzle))
    # END
    ok = checkPuzzle(puzzle, passPhrase, globals.salt)
   
    return ok

def handleInit(globals, passPhrase):

    while True:
        print(("passphrase is %s" % passwdStrength(passPhrase)))
        if confirmYorN('ok to continue? '):
            break
        passPhrase = getpass.getpass('new passphrase: ')
        if not passPhrase or passPhrase == '':
            print('you must supply a passphrase')
            sys.exit(1)

    # Neither the salt nor any IVs need be kept secret.
    salt    = bytes(globals.rng.someBytes(16))
    key     = bytes(PBKDF2(passPhrase, salt).read(32))     # 32-byte key

    # loop: verify that second passphrase matches first
    pp2     = getpass.getpass("Confirm passphrase: ")
    while pp2 != passPhrase:
        # DEBUG
        print("passphrase: %s" % passPhrase)
        print("pp2:        %s" % pp2)
        # END
        print("second passphrase does not match first passphrase")
        pp2 = getpass.getpass("Confirm passphrase: ")

    # DEBUG
    print("key: %s" % binascii.b2a_hex(key))
    # END

    #DESC = 'initialize magickSack'
    #parser = ArgumentParser(description=DESC, usage='magicSack init [options]')
    #parser.add_argument('-f', '--force', action='store_true',
    #    help='overwrite any existing configuration')
    #parser.add_argument('-j', '--justShow', action='store_true',
    #    help='show options and exit')
    #parser.add_argument('-T', '--testing', action='store_true',
    #    help='this is a test run')
    #parser.add_argument('-t', '--title', type=str,
    #    help='name of the magic sack (required)')
    #parser.add_argument('-u', '--uDir',
    #    help='path to uDir (relative to tmp/ if testing)')
    #parser.add_argument('-v', '--verbose',  action='store_true',
    #    help='be chatty')
    #args = parser.parse_args()

    # fixups
    globals.key = key

    appName    = globals.appName
    force      = globals.force
    magicDir   = globals.magicDir
    rng        = globals.rng
    title      = globals.title
    uDir       = globals.uDir
    usingSHA1  = globals.usingSHA1
    verbose    = globals.verbose

    #if args.testing:
    #    if magicDir == defaultDir:
    #        magicDir = os.path.join('tmp', '.magicsack')
    #    else:
    #        magicDir = os.path.join('tmp', '.magicsack')

    # sanity checks -------------------------------------------------

    # magicDir --------------------------------------------
    parts = magicDir.split('/')
    for part in parts:
        if part == '.' or part == '..':
            print("magicDir path '%s' may not contain '%s'" % (magicDir, part))
            sys.exit(1)

    if os.path.exists(magicDir):
        if force:
            shutil.rmtree(magicDir)
        else:
            print('%s already exists, add -f to continue' % magicDir)
            sys.exit(1)
    else:
        mkdir_p(magicDir, 0o700)

    # title -----------------------------------------------

    if not title or title == '':
        print('please supply a title, a name for your magic sack')
        # parser.print_help()
        # sys.exit(1)
        title = "NO TITLE"       # a hack

    # uDir ------------------------------------------------

    if not uDir or uDir == '':
        uDir = os.path.join(magicDir, 'uDir')
    globals.uDir = uDir

    parts = uDir.split('/')
    for part in parts:
        if part == '.' or part == '..':
            print("uDir path '%s' may not contain '%s'" % (uDir, part))
            sys.exit(1)

    if os.path.exists(uDir):
        if args.force:
            shutil.rmtree(uDir)
        else:
            print('%s already exists, add -f to continue' % uDir)
            sys.exit(1)
    else:
        mkdir_p(uDir, 0o700)

    # uDir/tmp --------------------------------------------
    uDirTmp = os.path.join(uDir, 'tmp')
    mkdir_p(uDirTmp, 0o700)

    # convert salt to something json can handle
    hexSalt = binascii.b2a_hex(salt).decode('utf-8')

    # DEBUG
    print("hexSalt = %s" % hexSalt)
    # END

    # ACTION --------------------------------------------------------

    # write configuration to magicDir ---------------------
    cfg = {'salt':hexSalt, 'uDir':uDir}
    jCfg = json.dumps(cfg, indent=2, sort_keys=True)
    # DEBUG
    print("JSON: %s" % jCfg)
    # END
    configFile = os.path.join(magicDir, 'cfg.json')
    with open(configFile, 'w') as f:
        f.write(jCfg)

    # write the puzzle file -------------------------------
    puzzle       = devisePuzzle(passPhrase, salt, rng)
    pathToPuzzle = os.path.join(magicDir, 'p')
    with open(pathToPuzzle, 'wb') as f:
        f.write(puzzle)

    # DEBUG
    print("puzzle written to %s" % pathToPuzzle)
    # END

    # generate two 2048 bit RSA private keys --------------
    ckPriv      = RSA.generate(2048)
    ckPrivPem   = ckPriv.exportKey('PEM')

    skPriv      = RSA.generate(2048)
    skPrivPem   = ckPriv.exportKey('PEM')
    sk          = skPriv.publickey()

    # create and populate NLHTree -------------------------
    tree        = NLHTree(title, usingSHA1)
    tree.insert(makeNamedValueLeaf(globals,'__ckPrivPem__', ckPrivPem))
    tree.insert(makeNamedValueLeaf(globals,'__skPrivPem__', skPrivPem))
    globals.sk      = sk
    globals.skPriv  = skPriv
    globals.tree    = tree
    writeBuildList(globals)


def handleDestroy(globals):
    print('destroy: not yet implemented')
    sys.exit(0)

def handleAddFile(globals):

    # DEBUG
    print("entering handleAddFile")
    # END

    #DESC = 'add something to magickSack'
    #parser = ArgumentParser(description=DESC)
    #parser.add_argument('-f', '--force', action='store_true',
    #    help='overwrite any existing configuration')
    #parser.add_argument('-j', '--justShow', action='store_true',
    #    help='show options and exit')
    #parser.add_argument('-T', '--testing', action='store_true',
    #    help='this is a test run')
    #parser.add_argument('-v', '--verbose',  action='store_true',
    #    help='be chatty')
    #args = parser.parse_args()

    # fixups
    magicDir    = globals.magicDir
    verbose     = globals.verbose 

    # echo back command line args -----------------------------------

    #appName = 'magicSack %s' % __version__
    #if args.verbose or args.justShow:
    #    print("%s %s" % (appName, __version_date__))

    #if args.verbose or args.justShow:
    #    print('justShow     = ' + str(args.justShow))
    #    print('magicDir     = ' + str(magicDir))
    #    print('testing      = ' + str(args.testing))
    #    print('verbose      = ' + str(verbose))

    #if args.justShow:
    #    sys.exit(0)

    # ACTION --------------------------------------------------------

    # XXX WORKING HERE

    print('add: not yet completelyimplemented')
    sys.exit(0)

def handleListFile(globals):
    print('list: not yet implemented')
    sys.exit(0)

def handleShowFile(globals):
    print('show: not yet implemented')
    sys.exit(0)

def handleDropFile(globals):
    print('drop: not yet implemented')
    sys.exit(0)

def handleAddPeer(globals):
    print('addPeer: not yet implemented')
    sys.exit(0)

def handleListPeer(globals):
    print('listPeer: not yet implemented')
    sys.exit(0)

def handleDropPeer(globals):
    print('dropPeer: not yet implemented')
    sys.exit(0)

def main():

    #   'globals' is the list of global args
    #   'command' is the first token after that
    #   'subArgs' is a list containing any other arguments found
    # So
    #   sys.args = [sys.argv[0]] + otherArgs

    defaultDir = os.path.join(os.getenv('HOME'), '.magicsack')

    DESC = 'command-line interface to the Magic Sack'
    parser = ArgumentParser(description=DESC)
    parser.add_argument('-1', '--usingSHA1', action='store_true',
        help='use SHA1 instead of the default, SHA2(56)')
    parser.add_argument('-f', '--force', action='store_true',
        help='execute command despite wornings')
    parser.add_argument('-j', '--justShow', action='store_true',
        help='show options and exit')
    parser.add_argument('-m', '--magicDir', default=defaultDir,
        help='select folder/directory (default=%s)' % defaultDir)
    parser.add_argument('-T', '--testing', action='store_true',
        help='this is a test run')
    parser.add_argument('-t', '--title', type=str,
        help='name of the magic sack (required)')
    parser.add_argument('-u', '--uDir',
        help='path to uDir (relative to tmp/ if testing)')
    parser.add_argument('-v', '--verbose',  action='store_true',
        help='be chatty')
    parser.add_argument('command',
        help='subCommand to be executed')
    parser.add_argument('subArgs', nargs='*',
        help='arguments to subCommand')
    globals = parser.parse_args()

    # DEBUG
    print("subArgs:")
    for ndx, x in enumerate(globals.subArgs):
        print("  %d %s" % (ndx, x))
    # END

    # fixups
    magicDir = globals.magicDir
    if globals.testing:
        if magicDir == defaultDir:
            magicDir = os.path.join('tmp', '.magicsack')
        else:
            magicDir = os.path.join('tmp', '.magicsack')
        globals.magicDir = magicDir
    if not magicDir or magicDir == '':
        print("magicDir must be specified")
        sys.exit(1)

    # set up the subcommand line ------------------------------------
    #sys.argv = [globals.command] + globals.subArgs

    # DEBUG
    #print("modified sys.argv:")
    #for ndx, arg in enumerate(sys.argv):
    #    print("  %d %s" % (ndx, arg))
    # END

    # echo back command line globals --------------------------------

    globals.appName = 'magicSack %s' % __version__
    if globals.verbose or globals.justShow:
        print("%s %s" % (globals.appName, __version_date__))

    if globals.verbose or globals.justShow:
        print('appName      = ' + str(globals.appName))
        print('command      = ' + str(globals.command))
        print('force        = ' + str(globals.force))
        print('justShow     = ' + str(globals.justShow))
        print('magicDir     = ' + str(magicDir))
        print('testing      = ' + str(globals.testing))
        print('title        = ' + str(globals.title))
        print('uDir         = ' + str(globals.uDir))
        print('usingSHA1    = ' + str(globals.usingSHA1))
        print('verbose      = ' + str(globals.verbose))
        #if globals.subArgs:
        #    for x in globals.subArgs:
        #        print('  %s' % x)

    if globals.justShow:
        sys.exit(0)

    passPhrase = getpass.getpass('passphrase: ')
    if not passPhrase or passPhrase == '':
        print('you must supply a passphrase')
        sys.exit(1)

    globals.rng = SystemRNG()
    command = globals.command
    if command   == 'init':
        handleInit(globals, passPhrase)
    else:
        if not verifyPassPhrase(globals, passPhrase):
            print('that was not the right passphrase!')
            sys.exit(1)
        if   command == 'destroy':      handleDestroy(globals)
        elif command == 'addFile':      handleAddFile(globals)
        elif command == 'listFile':     handleListFile(globals)
        elif command == 'showFile':     handleShowFile(globals)
        elif command == 'dropFile':     handleDropFile(globals)
        elif command == 'addPeer':      handleAddPeer(globals)
        elif command == 'listPeer':     handleListPeer(globals)
        elif command == 'dropPeer':     handleDropPeer(globals)
        else:
            print(("unrecogized command '%s'" % command))
            sys.exit(1)

if __name__ == '__main__':
    main()

