#!/usr/bin/python3
#
# ~/dev/py/magicsack/magicSack

import binascii, getpass, json, os, shutil, sys
from pbkdf2         import PBKDF2       # note name of package is u/c
from Crypto.Cipher  import AES
from argparse       import ArgumentParser

from xlattice.lfs   import mkdir_p
from xlattice.ui    import confirmYorN, passwdStrength
from magicsack      import *


def makeListing(args):

    testing     = args.testing
    uDir        = args.uDir
    verbose     = args.verbose

    # XXX STUB XX


def verifyPassPhrase(passPhrase):
    ok = True
    # .magicsack directory must exist
    # XXX STUB XXX
    return ok

def handleInit(passPhrase):

    while True:
        print(("passphrase is %s" % passwdStrength(passPhrase)))
        if confirmYorN('ok to continue? '):
            break
        passPhrase = getpass.getpass('new passphrase: ')
        if not passPhrase or passPhrase == '':
            print('you must supply a passphrase')
            sys.exit(1)

    # Neither the salt nor any IVs need be kept secret.
    salt    = os.urandom(8)
    key     = PBKDF2(passPhrase, salt).read(32)     # 32-byte key
    # iv    = os.urandom(16)                        # 16-byte IV
    # cipher= AES.new(key, AES.MODE_CBC, iv)

    # loop: verify that second passphrase matches first
    pp2     = getpass.getpass("Confirm passphrase: ")
    while pp2 != passPhrase:
        # DEBUG
        print("passphrase: %s" % passPhrase)
        print("pp2:        %s" % pp2)
        # END
        print("second passphrase does not match first passphrase")
        pp2 = getpass.getpass("Confirm passphrase: ")

    # DEBUG
    print("key: %s" % binascii.b2a_hex(key))
    # END

    defaultDir = os.path.join(os.getenv('HOME'), '.magicsack')

    DESC = 'initialize magickSack'
    parser = ArgumentParser(description=DESC, usage='magicSack init [options]')
    parser.add_argument('-f', '--force', action='store_true',
        help='overwrite any existing configuration')
    parser.add_argument('-j', '--justShow', action='store_true',
        help='show options and exit')
    parser.add_argument('-m', '--magicDir', default=defaultDir,
        help='select folder/directory (default=%s)' % defaultDir)
    parser.add_argument('-T', '--testing', action='store_true',
        help='this is a test run')
    parser.add_argument('-u', '--uDir', 
        help='path to uDir (relative to tmp/ if testing)')
    parser.add_argument('-v', '--verbose',  action='store_true',
        help='be chatty')
    args = parser.parse_args()
    
    appName = 'magicSack %s' % __version__

    # fixups
    magicDir = args.magicDir
    uDir     = args.uDir

    if args.testing:
        if magicDir == defaultDir:
            magicDir = os.path.join('tmp', '.magicsack')
        else:
            magicDir = os.path.join('tmp', '.magicsack')

    # sanity checks -------------------------------------------------

    # magicDir --------------------------------------------
    if not magicDir or magicDir == '':
        print("magicDir must be specified")
        sys.exit(1)
    if magicDir[0] == '/':
        print("magicDir is '%s' but may not be an absolute path" % magicDir)
        sys.exit(1)
    parts = magicDir.split('/')
    for part in parts:
        if part == '.' or part == '..':
            print("magicDir path '%s' may not contain '%s'" % (magicDir, part))
            sys.exit(1)

    if os.path.exists(magicDir):
        if args.force:
            shutil.rmtree(magicDir)
        else:
            print('%s already exists, add -f to continue' % magicDir)
            sys.exit(1)
    else:
        mkdir_p(magicDir, 0o700)

    # uDir ------------------------------------------------

    if not uDir or uDir == '':
        uDir = os.path.join(magicDir, 'uDir')

    if uDir[0] == '/':
        print("uDir is '%s' but may not be an absolute path" % uDir)
        sys.exit(1)
    parts = uDir.split('/')
    for part in parts:
        if part == '.' or part == '..':
            print("uDir path '%s' may not contain '%s'" % (uDir, part))
            sys.exit(1)

    if os.path.exists(uDir):
        if args.force:
            shutil.rmtree(uDir)
        else:
            print('%s already exists, add -f to continue' % uDir)
            sys.exit(1)
    else:
        mkdir_p(uDir, 0o700)

    # uDir/tmp --------------------------------------------
    uDirTmp = os.path.join(uDir, 'tmp')
    mkdir_p(uDirTmp, 0o700)

    # convert key to something json can handle 
    intSalt = int.from_bytes(salt, byteorder='little')
    # int.to_bytes(length, byteorder) reverses

    # echo back command line args -----------------------------------

    if args.verbose or args.justShow:
        print("%s %s" % (appName, __version_date__))

    if args.verbose or args.justShow:
        print('magicDir     = ' + str(magicDir))
        print('salt         = ' + str(intSalt))
        print('testing      = ' + str(args.testing))
        print('uDir         = ' + str(args.uDir))
        print('verbose      = ' + str(args.verbose))

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------
    cfg = {'salt':intSalt, 'uDir':uDir}
    jCfg = json.dumps(cfg)
    # DEBUG
    print("JSON: %s" % jCfg)
    # END
    configFile = os.path.join(magicDir, 'cfg.json')
    with open(configFile, 'w') as f:
        f.write(jCfg)

def handleDestroy():
    print('destroy: not yet implemented')
    sys.exit(0)

def handleAdd():
    print('add: not yet implemented')
    sys.exit(0)

def handleList():
    print('list: not yet implemented')
    sys.exit(0)

def handleShow():
    print('show: not yet implemented')
    sys.exit(0)

def handleDrop():
    print('drop: not yet implemented')
    sys.exit(0)

def handleAddPeer():
    print('addPeer: not yet implemented')
    sys.exit(0)

def handleListPeer():
    print('listPeer: not yet implemented')
    sys.exit(0)

def handleDropPeer():
    print('dropPeer: not yet implemented')
    sys.exit(0)

def main():
    if len(sys.argv) < 2:
        print("no command present: expect init, destroy, add, ...")
        sys.exit(1)
    command = sys.argv[1]
    if len(sys.argv) == 2:
        sys.argv = sys.argv[0:1]
    else:
        sys.argv = [sys.argv[0]] + sys.argv[2:]

    passPhrase = getpass.getpass('passphrase: ')
    if not passPhrase or passPhrase == '':
        print('you must supply a passphrase')
        sys.exit(1)

    if command   == 'init':         
        handleInit(passPhrase)
    else:
        # verifyPassPhrase
        if not verifyPassPhrase(passPhrase):
            print('that was not the right passphrase!')
            sys.exit(1)
        if command == 'destroy':      handleDestroy()
        elif command == 'add':          handleAdd()
        elif command == 'list':         handleList()
        elif command == 'show':         handleShow()
        elif command == 'drop':         handleDrop()
        elif command == 'addPeer':      handleAddPeer()
        elif command == 'listPeer':     handleListPeer()
        elif command == 'dropPeer':     handleDropPeer()
        else:
            print(("unrecogized command '%s'" % command))
            sys.exit(1)

if __name__ == '__main__':
    main()

