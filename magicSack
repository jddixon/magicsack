#!/usr/bin/python3

# ~/dev/py/magicsack/magicSack

import binascii
import getpass
import json
import os
import shutil
import sys
import time

from pbkdf2 import PBKDF2       # note name of package is u/c
from Crypto.Cipher import AES
from Crypto.Hash import SHA        # presumably SHA1
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_PSS
from argparse import ArgumentParser

from buildList import BuildList
from nlhtree import NLHTree
from rnglib import SimpleRNG, SystemRNG
from xlattice import Q
from xlattice.crypto import AES_BLOCK_SIZE, addPKCS7Padding, stripPKCS7Padding
from xlattice.u import UDir
from xlattice.ui import confirmYorN, passwdStrength
from magicsack import *


def verifyPassPhrase(globalNS, passPhrase):
    # DEBUG
    #print("entering verifyPassPhrase")
    #print("globalNS is a ", type(globalNS))
    # END
    ok = True
    magicPath = globalNS.magicPath
    if not os.path.exists(magicPath):
        print("%s does not exist; cannot continue" % magicPath)
        sys.exit(1)
    configFile = os.path.join(magicPath, 'cfg.json')
    if not os.path.exists(configFile):
        print("%s does not exist; cannot continue" % configFile)
        sys.exit(1)
    try:
        with open(configFile, 'r') as f:
            data = f.read()
    except Exception as e:
        print("error reading configuration file: %s" % e)
        sys.exit(1)
    try:
        cfg = json.loads(data)
    except Exception as e:
        print("error parsing json configuration file: %s" % e)
        sys.exit(1)
    # DEBUG
    print("CONFIGURATION:")
    print(data)
    # END

    globalNS.hexSalt = cfg['salt']
    globalNS.salt = binascii.a2b_hex(globalNS.hexSalt)
    # DEBUG
    #print("salt as seen by verify:\n    %s" % binascii.b2a_hex(globalNS.salt).decode('utf-8'))
    # END
    globalNS.uPath = cfg['uPath']

    # Read the puzzle file, then check that the salt encrypted there
    # matches the salt in the configuration file.  If it doesn't, the
    # key and therefore the passphrase are wrong.

    pathToPuzzle = os.path.join(magicPath, 'p')
    with open(pathToPuzzle, 'rb') as f:
        puzzle = f.read()
    # DEBUG
    #print("puzzle read from disk (%d bytes):" % len(puzzle))
    #print("%s" % binascii.b2a_hex(puzzle))
    # END
    ok = checkPuzzle(puzzle, passPhrase, globalNS.salt)

    return ok

# == init ===========================================================


def handleInit(globalNS, subArgv, passPhrase):

    rng = globalNS.rng
    while True:
        print(("passphrase is %s" % passwdStrength(passPhrase)))
        if confirmYorN('ok to continue? '):
            break
        passPhrase = getpass.getpass('new passphrase: ')
        if not passPhrase or passPhrase == '':
            print('you must supply a passphrase')
            sys.exit(1)

    # Neither the salt nor any IVs need be kept secret.
    salt = bytes(rng.someBytes(16))
    key = bytes(PBKDF2(passPhrase, salt).read(32))     # 32-byte key

    # loop: verify that second passphrase matches first
    pp2 = getpass.getpass("Confirm passphrase: ")
    while pp2 != passPhrase:
        # DEBUG
        print("passphrase: %s" % passPhrase)
        print("pp2:        %s" % pp2)
        # END
        print("second passphrase does not match first passphrase")
        pp2 = getpass.getpass("Confirm passphrase: ")

    # DEBUG
    print("key: %s" % binascii.b2a_hex(key))
    # END

    DESC = 'initialize magickSack'
    parser = ArgumentParser(description=DESC, usage='magicSack init [options]')
    parser.add_argument('-H', '--usingSHA', choices=[1, 2, 3], default=2,
                        help='using SHA1 hash algorithm (default is SHA256)')
    parser.add_argument('-f', '--force', action='store_true',
                        help='overwrite any existing configuration')
    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')
    parser.add_argument('-T', '--testing', action='store_true',
                        help='this is a test run')
    parser.add_argument('-t', '--title', type=str,
                        help='name of the magic sack (required)')
    parser.add_argument('-u', '--uPath',
                        help='path to uDir (relative to tmp/ if testing)')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')
    args = parser.parse_args(subArgv, namespace=globalNS)

    # fixups
    args.key = key
    args.rng = rng

    appName = globalNS.appName
    defaultDir = globalNS.defaultDir
    magicPath = globalNS.magicPath

    force = args.force
    title = args.title
    uPath = args.uPath
    usingSHA = Q(args.usingSHA)
    verbose = args.verbose

    if args.testing:
        rng = SimpleRNG(time.time())
        if magicPath == defaultDir:
            magicPath = os.path.join('tmp', '.magicsack')
        else:
            # XXX A MISTAKE:
            magicPath = os.path.join('tmp', '.magicsack')
    else:
        rng = SystemRNG()

    # sanity checks -------------------------------------------------

    # magicPath --------------------------------------------
    parts = magicPath.split('/')
    for part in parts:
        if part == '.' or part == '..':
            print("magicPath '%s' may not contain '%s'" % (magicPath, part))
            sys.exit(1)

    if os.path.exists(magicPath):
        if force:
            shutil.rmtree(magicPath)
        else:
            print('%s already exists, add -f to continue' % magicPath)
            sys.exit(1)
    else:
        os.makedirs(magicPath, mode=0o700, exist_ok=True)

    # title -----------------------------------------------

    if not title or title == '':
        print('please supply a title, a name for your magic sack')
        title = "NO_TITLE"       # a hack

    # uDir ------------------------------------------------

    if not uPath or uPath == '':
        uPath = os.path.join(magicPath, 'U')
    args.uPath = uPath

    if os.path.exists(uPath):
        if args.force:
            shutil.rmtree(uPath)
        else:
            print('%s already exists, add -f to continue' % uPath)
            sys.exit(1)
    globalNS.uDir = UDir.discover(uPath, mode=0o700)

    # uPath/tmp --------------------------------------------
    uPathTmp = os.path.join(uPath, 'tmp')
    if os.path.exists(uPathTmp):
        shutil.rmtree(uPathTmp)         # DANGEROUS
    os.makedirs(uPathTmp, mode=0o700)

    # convert salt to something json can handle
    hexSalt = binascii.b2a_hex(salt).decode('utf-8')

    # DEBUG
    print("hexSalt = %s" % hexSalt)
    # END

    # display command line values -----------------------------------
    if verbose:
        print("force        = %s" % force)
        print("magicPath     = %s" % magicPath)
        print("salt         = %s" % hexSalt)
        print("title        = %s" % title)
        print("uPath        = %s" % uPath)
        print("verbose      = %s" % verbose)

    # ACTION --------------------------------------------------------

    # write configuration to magicPath ---------------------
    cfg = {'salt': hexSalt, 'uPath': uPath}
    jCfg = json.dumps(cfg, indent=2, sort_keys=True)
    # DEBUG
    print("JSON: %s" % jCfg)
    # END
    configFile = os.path.join(magicPath, 'cfg.json')
    with open(configFile, 'w') as f:
        f.write(jCfg)

    # write the puzzle file -------------------------------
    puzzle = devisePuzzle(passPhrase, salt, rng)
    pathToPuzzle = os.path.join(magicPath, 'p')
    with open(pathToPuzzle, 'wb') as f:
        f.write(puzzle)

    # DEBUG
    print("puzzle written to %s" % pathToPuzzle)
    # END

    # generate two 2048 bit RSA private keys --------------
    ckPriv = RSA.generate(2048)
    ckPrivPem = ckPriv.exportKey('PEM')

    skPriv = RSA.generate(2048)
    skPrivPem = ckPriv.exportKey('PEM')
    sk = skPriv.publickey()

    # create and populate NLHTree -------------------------
    tree = NLHTree(nameFromTitle(title), usingSHA)
    tree.insert(makeNamedValueLeaf(args, '__ckPrivPem__', ckPrivPem))
    tree.insert(makeNamedValueLeaf(args, '__skPrivPem__', skPrivPem))
    args.magicPath = magicPath
    args.sk = sk
    args.skPriv = skPriv
    args.title = title
    args.tree = tree
    writeBuildList(args)

# == destroy ========================================================


def handleDestroy(globalNS, subArgv):

    DESC = 'erasing magickSack data from this machine'
    parser = ArgumentParser(description=DESC, usage='magicSack init [options]')

    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')
    parser.add_argument('-T', '--testing', action='store_true',
                        help='this is a test run')
    parser.add_argument('-q', '--quietly', action='store_true',
                        help='talk as little as possible')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')
    args = parser.parse_args(subArgv, namespace=globalNS)

    if args.verbose or args.justShow:
        print("justShow   = %s" % args.justShow)
        print("magicPath  = %s" % args.magicPath)   # DEBUG
        print("testing    = %s" % args.testing)
        print("quietly    = %s" % args.quietly)
        print("verbose    = %s" % args.verbose)
    if args.justShow:
        sys.exit(0)

    # get user confirmation
    prompt = "thoroughly delete your magicSack files? [yes/No] "
    while True:
        whether = input(prompt).capitalize()
        if not whether or whether[0] == 'N':
            sys.exit(0)
        elif whether[0] == 'Y':
            break
        else:
            print("please answer Y or N")

    # recursively scrub files and delete containing diretories

    # for each directoy
    #     for each file: get filesize, round up to multiple of 4 KB;
    #         for ecah block
    #             overwrite block with char, flush;
    #             overwrite with complement, flush;
    #             overwrite with random; flush;
    #         then delete the file
    #     then delete the directory

    quietly = args.quietly

    BLOCKSIZE = 4096
    CHAR = 0x74
    COMP = 0xff & (~CHAR)
    CHARS = bytes([CHAR for i in range(BLOCKSIZE)])
    COMPS = bytes([COMP for i in range(BLOCKSIZE)])
    RND = SimpleRNG(time.time()).someBytes(BLOCKSIZE)

    def scrubFile(pathToFile):
        info = os.stat(pathToFile)
        length = info.st_size
        count = int(0.000001 + (length + BLOCKSIZE - 1) / BLOCKSIZE)
        with open(pathToFile, 'wb') as f:
            for n in range(count):
                f.write(CHARS)
                f.flush()
        with open(pathToFile, 'wb') as f:
            for n in range(count):
                f.write(COMPS)
                f.flush()
        with open(pathToFile, 'wb') as f:
            for n in range(count):
                f.write(RND)
                f.flush()
        os.remove(pathToFile)
        if not args.quietly:
            print("file %s has been scrubbed" % pathToFile)

    def scrubDir(pathToDir):
        if not quietly:
            print("scrubbing %s" % globalNS.magicPath)
        files = os.listdir(pathToDir)
        for file in files:
            pathToFile = os.path.join(pathToDir, file)
            if os.path.isdir(pathToFile):
                scrubDir(pathToFile)
            elif os.path.isfile(pathToFile):
                scrubFile(pathToFile)
            elif os.path.islink(pathToFile):
                os.unlink(pathToFile)
            else:
                print("don't know how to handle %s" % pathToFile)
        if not quietly:
            print("directory %s scrubbed" % pathToDir)
        shutil.rmtree(pathToDir)

    scrubDir(globalNS.magicPath)

    sys.exit(0)

# == addFile ========================================================


def handleAddFile(globalNS, subArgv):
    """
    Prohibit adding files whose names begin with double-underscore ('__').
    """

    # DEBUG
    print("entering handleAddFile")
    # END

    DESC = 'add something to magickSack'
    parser = ArgumentParser(description=DESC)
    parser.add_argument('-f', '--force', action='store_true',
                        help='overwrite any existing configuration')
    parser.add_argument('-j', '--justShow', action='store_true',
                        help='show options and exit')
    parser.add_argument('-T', '--testing', action='store_true',
                        help='this is a test run')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='be chatty')
    args = parser.parse_args(namespace=globalNS)

    magicPath = globalNS.magicPath
    verbose = args.verbose

    # echo back command line args -----------------------------------

    appName = 'magicSack %s' % __version__
    if args.verbose or args.justShow:
        print("%s %s" % (appName, __version_date__))

    if args.verbose or args.justShow:
        print('justShow     = ' + str(args.justShow))
        print('magicPath     = ' + str(magicPath))
        print('testing      = ' + str(args.testing))
        print('verbose      = ' + str(verbose))

    if args.justShow:
        sys.exit(0)

    # ACTION --------------------------------------------------------

    # XXX WORKING HERE

    print('add: not yet completely implemented')
    sys.exit(0)


# == listFile =======================================================

def handleListFile(globalNS, subArgv):
    print('list: not yet implemented')
    sys.exit(0)


# == showFile ======================================================

def handleShowFile(globalNS, subArgv):
    print('show: not yet implemented')
    sys.exit(0)


# == dropFile =======================================================

def handleDropFile(globalNS, subArgv):
    """
    Prohibit deleting files whose names begin with double-underscore ('__')
    """
    print('drop: not yet implemented')
    sys.exit(0)

# == addPeer ========================================================


def handleAddPeer(globalNS, subArgv):
    print('addPeer: not yet implemented')
    sys.exit(0)


# == listPeer =======================================================

def handleListPeer(globalNS, subArgv):
    print('listPeer: not yet implemented')
    sys.exit(0)


# == dropPeer =======================================================

def handleDropPeer(globalNS, subArgv):
    print('dropPeer: not yet implemented')
    sys.exit(0)


# == main ===========================================================

def main():
    """
    The command line looks like
        magicSack [-m MAGIC_DIR] SUBCMD otherArgs
    So at the top level we peek at sys.argv[1].  If it's '-m' or
    '--magicPath' we will collect it and its parameter here and
    process sys.argv[4:] as subArgv.  Otherwise we process sys.argv[2:]
    as subArgv in the subcommand.
    """

    funcMap = {
        'init': handleInit,
        'destroy': handleDestroy,
        'addFile': handleAddFile,
        'listFile': handleListFile,
        'showFile': handleShowFile,
        'dropFile': handleDropFile,
        'addPeer': handleAddPeer,
        'listPeer': handleListPeer,
        'dropPeer': handleDropPeer,
    }
    argv = sys.argv

    defaultDir = os.path.join(os.getenv('HOME'), '.magicsack')
    subCmdAt = 1
    if len(argv) >= 4:
        if argv[1] == '-m' or argv[1] == '--magicPath':
            subCmdAt = 3

    # DEBUG
    print("SUB CMD AT %d" % subCmdAt)
    # END

    DESC = 'command-line interface to the Magic Sack'
    parser = ArgumentParser(description=DESC)
    parser.add_argument('-m', '--magicPath', default=defaultDir, type=str,
                        help='select folder/directory (default=%s)' % defaultDir)
    parser.add_argument('command',          # required
                        help='subCommand to be executed')
    globalNS = parser.parse_args(sys.argv[1: subCmdAt + 1])

    globalNS.appName = 'magicSack %s' % __version__
    globalNS.defaultDir = defaultDir

    subArgv = sys.argv[subCmdAt + 1:]

    # DEBUG
    print("subArgv:")
    for ndx, x in enumerate(subArgv):
        print("  %d %s" % (ndx, x))
    # END

    # fixups
    magicPath = globalNS.magicPath
    globalNS.rng = SystemRNG()

    # DEBUG
    print("magicPath: %s" % magicPath)
    # END

    if not magicPath:
        print("magicPath must be specified")
        sys.exit(1)

    passPhrase = getpass.getpass('passphrase: ')
    if not passPhrase or passPhrase == '':
        print('you must supply a passphrase')
        sys.exit(1)
    globalNS.passPhrase = passPhrase
    command = globalNS.command
    if command == 'init':
        handleInit(globalNS, subArgv, passPhrase)
    else:
        if not verifyPassPhrase(globalNS, passPhrase):
            print('that was not the right passphrase!')
            sys.exit(1)
        funcMap[command](globalNS, subArgv)

if __name__ == '__main__':
    main()
